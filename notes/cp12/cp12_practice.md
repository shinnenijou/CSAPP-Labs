# Chapter 12 并发编程

## 练习题12.1
子进程在父进程关闭描述符前被创建，因此继承了父进程的整个内存空间，包括描述符的打开状态。因此即使父进程随后关闭描述符也不会影响子进程对文件的读写。

## 练习题12.2
子进程退出时内核会自动关闭子进程中打开的所有描述符。在此显式关闭仅仅是出于良好编程习惯。

## 练习题12.3
`select`检测到标准输入的输入后会正常返回，程序进入`command`进行读取，此时`Fget`读取到`EOF`后进入分支使进程退出。

## 练习题12.4
因为`Select`函数会将输入的`pool.ready_set`改写成本次检测到的准备好的描述符，如果不进行重置，`Select`将会只检测上一次循环的ready_set中的描述符。

## 练习题12.5
因为所有对等线程都在同一个进程中，共享同一个描述符表，在进程中关闭描述符关闭的也是进程的描述符，因此只需要在线程中关闭一次即可。

## 练习题12.6
| 变量实例 | 主线程引用的 | 对等线程0引用的？ | 对等线程1引用的？ |
| -------- | ------------ | ----------------- | ----------------- |
| ptr      | yes          | yes               | yes               |
| cnt      | no           | yes               | yes               |
| i.m*     | yes          | no                | no                |
| msgs.m   | yes          | no                | no                |
| myid.p0  | no           | yes               | no                |
| myid.p1  | no           | no                | yes               |
*注意：虽然在主线程中将i传递给了两个对等线程，但传的是i的值（虽然转换为了指针）因此在对等线程中不会引用到i.m变量

## 练习题12.7
| 步骤 | 线程 | 指令  | %rdx1 | %rdx2 | cnt |
| ---- | ---- | ----- | ----- | ----- | --- |
| 1    | 1    | $H_1$ | ー    | ー    | 0   |
| 2    | 1    | $L_1$ | 0     | ー    | 0   |
| 3    | 2    | $H_2$ | ー    | ー    | 0   |
| 4    | 2    | $L_2$ | ー    | 0     | 0   |
| 5    | 2    | $U_2$ | ー    | 1     | 0   |
| 6    | 2    | $S_2$ | ー    | 1     | 1   |
| 7    | 1    | $U_1$ | 1     | ー    | 1   |
| 8    | 1    | $S_1$ | 1     | ー    | 1   |
| 9    | 1    | $T_1$ | 1     | ー    | 1   |
| 10   | 2    | $T_2$ | ー    | 1     | 1   |
无法产生正确的cnt值

## 练习题12.8
A: 安全
B: 不安全
C: 安全

## 练习题12.9
A. 互斥锁是必须的
B. 互斥锁不是必须的，因为缓冲区大小只有1, 空槽为0时生产者被阻塞，空槽为1时消费者被阻塞，指示空槽的信号量实质起到了互斥的作用。
C. 互斥锁不是必须的, 理由同B

## 练习题12.11
|                 |      |     |     |
| --------------- | ---- | --- | --- |
| 线程($t$)       | 1    | 2   | 4   |
| 核($p$)         | 1    | 2   | 4   |
| 运行时间($T_p$) | 12   | 8   | 6   |
| 加速比($S_p$)   | 1    | 1.5 | 2   |
| 效率($E_p$)     | 100% | 75% | 50% |

## 练习题12.12
在`ctime_ts`调用的`ctime`将返回保存在一个静态变量的指针，这个静态指针将在所有线程间共享，因此整个函数依然不是可重入的。但函数在调用`ctime`时上了互斥锁，保证不同线程不会同时访问该静态变量，因此该函数是线程安全的。

## 练习题12.13
主线程释放内存的语句将会和对等线程中读取该内存的语句产生竞争。一旦主线程先于对等线程释放该内存，对等线程的解引用就将产生未定义行为。

## 练习题12.14
A. 声明一个`int array[N];`, 在循环中赋值并只传递数组对应部分给对等线程
B. 如果线程数量比较多那内存使用会大一些

## 练习题12.15
B. t初始为0所以两个线程都会阻塞在`P(t)`语句
C. 初始设置t为0即可