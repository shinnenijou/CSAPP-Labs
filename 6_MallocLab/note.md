# Malloc Lab

## Implicit List
首先参考教材中的实现尝试实现隐式链表。相比教材中的隐式链表这里做出一些变化
* 已分配的块不使用额外的尾部空间记录块大小和分配状态，仅在未分配的块尾部记录。在分配或回收当前块时，同步将分配状态记录在下一个块的头部。

做出这样改变的理由是, 尾部cookie的用途本身只是为了便于在合并块时向前合并。当前一个块已经分配出去时，本身也不需要该cookie。
相应的对于未被分配的块, 尾部空间本来就可以由malloc库随意使用。因此通过这样的记录可以让我们不必为尾部cookie单独预留空间，可以提高小区块的分配空间利用率。  

在实现上需要在每次标记块为已分配或空闲块时同步修改下一个块的头部。`Epilogue`块的存在保证了我们在操作时始终不会越界。

其他地方则基本按照教材中的参考代码进行实现，不多赘述。

## Explicit List
显式链表的实现可以给予隐式链表的实现进行优化。由于显式链表和隐式链表的主要区别仅在于寻找匹配的空闲块时使用自由链表进行搜索, 其他在物理块上合并、分割、申请(即拓展堆空间)没有区别。因此只需要额外维护一个自由链表，在进行物理块合并分割申请等操作时, 同时添加或从自由链表中移出即可。

本实现中使用环状双向链表，并设置一个始终不被使用的哨兵块以减少边界条件的检查。为了确保每个块都有足够的空间容纳双向链表，重新定义最小块大小
```
#define WSIZE sizeof(size_t)
#define PSIZE sizeof(void *)
#define MIN_BLOCK_SIZE (ALIGN(WSIZE + PSIZE + PSIZE + WSIZE))
```
该块大小在32位时为16字节, 64位时为32字节, payload始终对齐至从第8字节开始。这样可以保证不论32位还是64位，在该块被分配时记录`size`等信息的`header`始终不会被覆盖，同时更加节省因对齐导致的空间浪费。

接着定义自由链表中节点的前后连接
```
#define NEXT_FREE_OFFSET WSIZE
#define PREV_FREE_OFFSET (WSIZE + PSIZE)
#define NEXT_FREE_PTR(bp) ((void *)GET(HEADER_PTR(bp) + NEXT_FREE_OFFSET))
#define PREV_FREE_PTR(bp) ((void *)GET(HEADER_PTR(bp) + PREV_FREE_OFFSET))
```
同时为了更方便的继续扩展至分离式链表, 实现中选择将自由链表的哨兵节点放置在堆空间起始物理块`HEAD`之前, 这样无论如何修改自由链表的实现都不会影响后续的物理块。

其他双向列表的操作使用这些宏操作原始指针即可。维护自由链表的过程中可以有一些微小的优化
* 合并块时, 如果前一个块是空闲块, 则前一个块应当已经存在于自由链表中, 这时候就不需要对链表进行修改, 仅修改前一个块的大小即可(常规合并)
* 分配切割块时，由于当前块本身就是在自由链表中，可以从后向前切割，这样就可以不用再修改自由链表。仅在无法切割时将块从自由链表中移除

## Segregated List
基于显式链表的实现, 分离链表的实现不需要对物理块的操作进行修改，只需要维护多个不同大小的显式链表即可。在插入时根据块大小进行插入，在搜索匹配时根据块大小进行搜索。

根据块大小进行操作时一个很关键影响性能的问题在于如何快速找到块大小对应的块。这里采用的方案是将多个自由链表按照块大小顺序从小到大排列放置在物理块前方的区域, 全局保存起始块的位置, 使用时根据块大小进行偏移。具体定义以下宏
```
static void *FREE_LIST_BEGIN = NULL;
#define FREE_LIST(size) ((char *)FREE_LIST_BEGIN + ((size - 1) / ALIGNMENT) * MIN_BLOCK_SIZE)
```
使用该宏需要保证传入的`size`都是经过8字节对齐的大小。

后续修改多个链表初始化和插入操作中对插入链表的选择即可。在分离链表的实现时，双向链表中使用到的一些小优化将不再可用
* 合并块时，如果前一个块是空闲块，此时合并后新的块大小可能需要放置在更大的自由链表中，因此始终需要将前一个块移除后重新插入
* 分配切割块时，与合并相同的理由，也需要将切割后的块重新插入